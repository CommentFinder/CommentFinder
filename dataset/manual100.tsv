public boolean equals(Object that) { if (this == that) { return true; } if (that instanceof Rating) { Rating other = (Rating) that; return type.equals(other.type) && value == other.value && numberOfVotes.equals(other.numberOfVotes); } return false; }
public synchronized void dispose() { ILaunchManager launchManager = DebugPlugin.getDefault().getLaunchManager(); launchManager.removeLaunchConfigurationListener(this); launchManager.removeLaunchListener(this); for (ISourceLookupParticipant participant : fParticipants) { if(participant != this) { participant.dispose(); } } fParticipants.clear(); if (fSourceContainers != null) { for (ISourceContainer fSourceContainer : fSourceContainers) { fSourceContainer.dispose(); } } fSourceContainers = null; fResolvedElements = null; }
@Override protected void onEntityAdded(Entity member) { try { ((MongoDBReplicaSetImpl) entity).serverAdded((MongoDBServer) member); } catch (Exception e) { ServiceStateLogic.ServiceNotUpLogic.updateNotUpIndicator((EntityLocal)member, "Failed to update replicaset", e); } }
private void testSanitization() throws IOException { ______TS("Test sanitization for edit page"); instructorId = testData.accounts.get("instructor1OfTestingSanitizationCourse").googleId; FeedbackSessionAttributes session = testData.feedbackSessions.get("session1InTestingSanitizationCourse"); courseId = session.getCourseId(); feedbackSessionName = session.getFeedbackSessionName(); feedbackEditPage = getFeedbackEditPage(); feedbackEditPage.verifyHtmlMainContent("instructorFeedbackEditPageTestingSanitization.html"); ______TS("Test sanitization for copy question modal"); feedbackEditPage.clickCopyButton(); feedbackEditPage.waitForCopyTableToLoad(); feedbackEditPage.verifyHtmlPart(By.id("copyModal"), "/instructorFeedbackCopyQuestionModalTestingSanitization.html"); }
public TextArgs add(Object... args) { if (positionedArgsBuilder == null) { throw new IllegalArgumentException("Positioned arguments were already accessed, to add" + "more arguments use TextArgs.copy()"); } positionedArgsBuilder.add(args); return this; }
public List getList(String key) { for (Config child : children) { if (child.containsKey(key)) { return child.getList(key); } } return null; }
Mono<Response<RecognizePiiEntitiesResult>> recognizePiiEntitiesWithResponse(String text, String language, Context context) { return recognizeBatchPiiEntitiesWithResponse( Arrays.asList(new TextDocumentInput(Integer.toString(0), text, language)), null, context) .flatMap(response -> { Iterator<RecognizePiiEntitiesResult> responseItem = response.getValue().iterator(); return Mono.just(new SimpleResponse<>(response, responseItem.next())); }); }
public static <T> FactorComparator<T> create(String factorName, int weight, Comparator<T> comparator){ if (null == factorName || factorName == "" || weight < 0 || null == comparator){ logger.error("failed to create instance of FactorComparator, at least one of the input paramters are invalid"); return null; } return new FactorComparator<T>(factorName,weight,comparator); }
public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings) { if (args.size() != 2) { throw new IllegalArgumentException("function '" + name() + "' needs 2 argument"); } Expr expr1 = args.get(0); Expr expr2 = args.get(1); return eval(expr1.eval(bindings), expr2.eval(bindings)); }
public static IGerritHudsonTriggerConfig getConfig(String serverName) { return PluginImpl.getInstance().getServer(serverName).getConfig(); }
public void setObject_unmanagedObjectThrows() { RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll(); realm.beginTransaction(); try { collection.setObject(AllTypes.FIELD_REALMOBJECT, new Dog()); fail(); } catch (IllegalArgumentException e) { assertTrue("Wrong error message: " + e.getMessage(), e.getMessage().contains("is not a valid a valid, managed Realm object.")); } }
public Update createStatement(String sql) { Foreman updateForeman = foreman.createChild(); return new Update(this, statementLocator, statementRewriter, statementBuilder, sql, new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman), timingCollector, updateForeman, collectorFactoryRegistry); }
public void execute(JobDelegateDataBean data) { try { executeDelegate(data); } catch (Exception e) { Logger.error(this, "An error occurred when running the Job Delegate: " + this.getClass(), e); } finally { try { HibernateUtil.closeSession(); } catch (DotHibernateException e) { Logger.warn(this, e.getMessage(), e); } } }
public void nextJsonObject_ArrayOfElements() throws JsonParseException, IOException { String element1 = normalizeJson("{bre: 'sss', arr: ['1112', 'abc']}"); String element2 = normalizeJson("{bre: 'sss', arr: ['1112', 'abc'], dd: 'ssssxx'}"); String content = "[" + element1 +", " + element2 + "]"; JsonParser jsonParser = jsonFactory.createParser(content); JsonToken jsonToken = jsonUtils.nextJsonObject(jsonParser); assertEquals(content.replaceAll("\\s", ""), jsonParser.readValueAsTree().toString()); jsonToken = jsonUtils.nextJsonObject(jsonParser); assertNull(jsonToken); }
public PreparedOperationWithReactiveStream<Cursor> prepare() { Checks.checkNotNull(query, "Please specify query"); if (getResolver == null) { getResolver = DefaultGetResolver.INSTANCE; } return new PreparedGetCursor( storIOContentProvider, getResolver, query ); }
public void designDocSync() throws MalformedURLException { DesignDocument designDoc = DesignDocumentManager.fromFile(designDocExample); db.getDesignDocumentManager().put(designDoc); }
protected String getLaunchDebugCommand(JBossServer jbossServer) throws CoreException { String programArguments = getLaunchProgramArgs(); String vmArguments = getLaunchVMArgs(); String jar = getJar(jbossServer.getServer()); String debugPort = getDebugPort(); String debugArgs = "-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=" + debugPort + " -Xdebug "; String command = "java " + debugArgs + vmArguments + " -jar " + jar + " " + IJBossRuntimeConstants.SPACE + programArguments + "&"; return command; }
public void testCreateInvalidConfigAeadWithAuth() throws Exception { IpSecConfig ipSecConfig = buildBasicIpSecConfig(); for (int direction : directions) { ipSecConfig.setAuthentication(direction, authAlgo); try { ipSecConfig.setAuthenticatedEncryption(direction, aeadAlgo); } catch (IllegalArgumentException expected) { } } try { mIpSecService.createTransportModeTransform(ipSecConfig, new Binder()); fail( "IpSecService should have thrown an error on authentication being" + " enabled with authenticated encryption"); } catch (IllegalArgumentException expected) { } }
public boolean isUnifiable(Index index) { return index instanceof TopIndex || equals(index) || (index instanceof TokenIndex && kLabel.sorts().contains(((TokenIndex) index).sort())); }
static void writeModel(NaiveBayesModel model) throws IOException { ensureTextClassifierFolderExists(); FileWriter fw = new FileWriter(new File(MODEL_PATH)); PlainTextNaiveBayesModelWriter modelWriter; modelWriter = new PlainTextNaiveBayesModelWriter(model, new BufferedWriter(fw)); modelWriter.persist(); fw.close(); }
public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { ArgChecker.notNull(index, "currency"); ArgChecker.notNull(forwardCurve, "forwardCurve"); this.indexCurves.put(index, forwardCurve); return this; }
@Override public E remove() { lock.lock(); try { if (queue.isEmpty()) { throw new NoSuchElementException(); } E peek = queue.peek(); queue.remove(); return peek; } catch (IOException e) { QueueFile.<Error>getSneakyThrowable(e); return null; } finally { lock.unlock(); } }
public String toString() { return String.format("byte@0x%x=0x%x (%d)", Pointer.nativeValue(getPointer()), getValue(), getValue()); }
Builder addClientCapabilities(Collection<String> clientCapabilities) { for (String cap: clientCapabilities) { if (cap.startsWith("agent=")) { setAgent(cap.substring("agent=".length())); } else { clientCaps.add(cap); } } return this; }
public void deactivate() { logger.debug("Deactivate"); }
private static Instant retrieveDeadlineTimestamp(JobDataMap jobDataMap) { Object timestamp = jobDataMap.get(MESSAGE_TIMESTAMP); if (timestamp instanceof String) return Instant.parse(timestamp.toString()); return Instant.ofEpochMilli((long) timestamp); }
public synchronized long getTimestamp(final int offset) { HistogramScaledData scaledData = fScaledData; if (scaledData != null) { return fScaledData.fFirstBucketTime + (long) (0.5 + (fScaledData.fBucketDuration * offset)); } return 0; }
private <T extends Enum<T>> void registerStatistic(String statNameSuffix, StatisticType type, final OperationStatisticDescriptor<T> descriptor, final EnumSet<T> outcomes) { if (contextObject == null) { return; } Set<TreeNode> result = queryBuilder() .descendants() .filter(context(attributes(Matchers.<Map<String, Object>>allOf( hasAttribute("type", descriptor.getType()), hasAttribute("name", descriptor.getObserverName()), hasAttribute("tags", new Matcher<Set<String>>() { @Override protected boolean matchesSafely(Set<String> object) { return object.containsAll(descriptor.getTags()); } }))))) .filter(context(identifier(subclassOf(OperationStatistic.class)))) .build().execute(Collections.singleton(ContextManager.nodeFor(contextObject))); if (!result.isEmpty()) { for (TreeNode node : result) { String discriminator = null; Map<String, Object> properties = (Map<String, Object>) node.getContext().attributes().get("properties"); if (properties != null && properties.containsKey("discriminator")) { discriminator = properties.get("discriminator").toString(); } String fullStatName = (discriminator == null ? "" : (discriminator + ":")) + statNameSuffix; final OperationStatistic<T> statistic = (OperationStatistic<T>) node.getContext().attributes().get("this"); registerStatistic(fullStatName, type, new ValueStatistic<Number>() { @Override public Number value() { return statistic.sum(outcomes); } }); } } }
public void process(String sessionId, String taskId, NodeId agentId, NodeContext nodeContext, SystemInfo systemInfo) { String serviceId = getKey(sessionId, taskId); if (!metricServiceMap.containsKey(serviceId)){ metricServiceMap.put(serviceId, new DefaultMetricService(sessionId, taskId, nodeContext)); } saveMonitoringValues(serviceId, agentId.getIdentifier(), systemInfo.getSysInfo()); if (systemInfo.getSysUnderTest() == null){ return; } for (Map.Entry<String, SystemUnderTestInfo> entry : systemInfo.getSysUnderTest().entrySet()){ saveMonitoringValues(serviceId, entry.getKey(), entry.getValue().getSysUTInfo()); } log.trace("System info {} received from agent {} and has been written to FileStorage", systemInfo, agentId); }
private void finalizeMetadataChunk() { finalBlobProperties = new BlobProperties(getBlobSize(), passedInBlobProperties.getServiceId(), passedInBlobProperties.getOwnerId(), passedInBlobProperties.getContentType(), passedInBlobProperties.isPrivate(), passedInBlobProperties.getTimeToLiveInSeconds(), passedInBlobProperties.getCreationTimeInMs(), passedInBlobProperties.getAccountId(), passedInBlobProperties.getContainerId(), false); if (getNumDataChunks() > 1) { List<StoreKey> orderedChunkIdList = new ArrayList<>(indexToChunkIds.values()); buf = MetadataContentSerDe.serializeMetadataContent(routerConfig.routerMaxPutChunkSizeBytes, getBlobSize(), orderedChunkIdList); onFillComplete(false); } else { blobId = (BlobId) indexToChunkIds.get(0); state = ChunkState.Complete; operationCompleted = true; } }
public static void testGetCentresByBranch() throws MambuApiException { methodName = new Object() {}.getClass().getEnclosingMethod().getName(); System.out.println(methodName = "\nIn " + methodName); OrganizationService organizationService = MambuAPIFactory.getOrganizationService(); String branchId = BRANCH_ID; String offset = "0"; String limit = "500"; System.out.println( "\nIn testGetCentresByBranch" + " BranchID=" + branchId + " Offset=" + offset + " Limit=" + limit); Date d1 = new Date(); List<Centre> centres = organizationService.getCentres(branchId, offset, limit); Date d2 = new Date(); long diff = d2.getTime() - d1.getTime(); System.out.println("Total Centres=" + centres.size() + " for branch=" + branchId + ". Total time=" + diff); for (Centre centre : centres) { System.out.println(" Name=" + centre.getName() + "\tId=" + centre.getId()); } System.out.println(); }
public void copyRightToLeft(Diff target, Monitor monitor) { if (target.getState() != DifferenceState.UNRESOLVED) { return; } long start = System.currentTimeMillis(); target.setState(DifferenceState.MERGED); final Set<Diff> dependencies = getDirectMergeDependencies(target, true); boolean requiresMerging = requiresMerging(target, true); for (Diff mergeMe : dependencies) { mergeDiff(mergeMe, true, monitor); } for (Diff transitiveMerge : getDirectResultingMerges(target, true)) { transitiveMerge.setState(DifferenceState.MERGED); } if (requiresMerging) { if (target.getSource() == DifferenceSource.LEFT) { reject(target, true); } else { accept(target, true); } } if (isHandleSubDiffs()) { Set<Diff> subDiffs = Sets.newLinkedHashSet(ComparisonUtil.getDirectSubDiffs(false).apply(target)); for (Diff subDiff : subDiffs) { mergeDiff(subDiff, true, monitor); } } if (LOGGER.isDebugEnabled()) { long duration = System.currentTimeMillis() - start; LOGGER.debug("copyLeftToRight(Diff, Monitor) - diff " + target.hashCode() + " merged in " + duration + "s"); } }
public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView, times(1)).setExpanded(true); verify(dragComponentGroupView, times(1)).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }
public List<URI> uploadAllFromHome(String inVerzeichnis) { User currentUser = Helper.getCurrentUser(); ArrayList<URI> files = new ArrayList<>(); FilenameFilter filter = new FileNameEndsWithFilter("]"); try { if (currentUser != null) { URI directoryName = serviceManager.getUserService().getHomeDirectory(currentUser).resolve(inVerzeichnis); files = fileService.getSubUris(filter, directoryName); } else { Helper.setFehlerMeldung("uploadFromHomeAlle abgebrochen, Fehler - no user assigned"); return files; } } catch (IOException ioe) { logger.error("Exception uploadFromHomeAlle()", ioe); Helper.setFehlerMeldung("uploadFromHomeAlle abgebrochen, Fehler", ioe.getMessage()); return files; } for (URI data : files) { String dataString = data.toString(); if (dataString.endsWith("/") || dataString.endsWith("\\")) { data = URI.create(dataString.substring(0, dataString.length() - 1)); } if (data.toString().contains("/")) { data = URI.create(dataString.substring(dataString.lastIndexOf("/"))); } } return files; }
private List<AccountInfo> suggestAccount(VisibilityControl visibilityControl) throws OrmException { if (!suggestAccounts) { return Collections.emptyList(); } final String a = query; final String b = a + MAX_SUFFIX; final LinkedHashMap<Account.Id, AccountInfo> r = new LinkedHashMap<Account.Id, AccountInfo>(); for (final Account p : dbProvider.get().accounts() .suggestByFullName(a, b, limit)) { addSuggestion(r, p, new AccountInfo(p.getId()), visibilityControl); } if (r.size() < limit) { for (final Account p : dbProvider.get().accounts() .suggestByPreferredEmail(a, b, limit - r.size())) { addSuggestion(r, p, new AccountInfo(p.getId()), visibilityControl); } } if (r.size() < limit) { for (final AccountExternalId e : dbProvider.get().accountExternalIds() .suggestByEmailAddress(a, b, limit - r.size())) { if (!r.containsKey(e.getAccountId())) { final Account p = accountCache.get(e.getAccountId()).getAccount(); final AccountInfo info = new AccountInfo(p.getId()); addSuggestion(r, p, info, visibilityControl); } } } return new ArrayList<AccountInfo>(r.values()); }
public String generateTOTPTokenLocal(String username) throws TOTPException { long token = 0; try { int tenantId = IdentityUtil.getTenantIdOFUser(username); UserRealm userRealm = TOTPManagerComponent.getRealmService().getTenantUserRealm(tenantId); if (userRealm != null) { UserStoreManager userStoreManager = userRealm.getUserStoreManager(); String secretKey = userStoreManager.getUserClaimValue(MultitenantUtils.getTenantAwareUsername (username), Constants.SECRET_KEY, null); byte[] secretkey; String encoding = "Base32"; try { encoding = TOTPUtil.getEncodingMethod(); } catch (IdentityApplicationManagementException e) { log.error("Error when fetching the encoding method"); } if ("Base32".equals(encoding)) { Base32 codec32 = new Base32(); secretkey = codec32.decode(secretKey); } else { Base64 code64 = new Base64(); secretkey = code64.decode(secretKey); } try { token = getCode(secretkey, getTimeIndex()); if (log.isDebugEnabled()) { log.debug("Token is sent to via email. token : " + token); } log.info("Generated token : " + token); } catch (NoSuchAlgorithmException e) { throw new TOTPException("TOTPTokenGenerator can't find the configured hashing algorithm", e); } catch (InvalidKeyException e) { throw new TOTPException("Secret key is not valid", e); } } else { throw new TOTPException("Cannot find the user realm for the given tenant domain : " + CarbonContext .getThreadLocalCarbonContext().getTenantDomain()); } } catch (IdentityException e) { throw new TOTPException("TOTPTokenGenerator failed while trying to get the tenant ID of the user " + username, e); } catch (UserStoreException e) { throw new TOTPException("TOTPTokenGenerator failed while trying to access userRealm of the user : " + username, e); } return Long.toString(token); }
protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.fui_auth_method_picker_layout); FlowParameters params = getFlowParams(); mHandler = ViewModelProviders.of(this).get(SimpleProvidersHandler.class); mHandler.init(params); populateIdpList(params.providerInfo, mHandler); int logoId = params.logoId; if (logoId == AuthUI.NO_LOGO) { findViewById(R.id.logo).setVisibility(View.GONE); ConstraintLayout layout = findViewById(R.id.root); ConstraintSet constraints = new ConstraintSet(); constraints.clone(layout); constraints.setHorizontalBias(R.id.container, 0.5f); constraints.setVerticalBias(R.id.container, 0.5f); constraints.applyTo(layout); } else { ImageView logo = findViewById(R.id.logo); logo.setImageResource(logoId); } mHandler.getOperation().observe(this, new Observer<Resource<IdpResponse>>() { @Override public void onChanged(Resource<IdpResponse> resource) { if (resource.getState() == State.LOADING) { getDialogHolder().showLoadingDialog(R.string.fui_progress_dialog_signing_in); return; } getDialogHolder().dismissDialog(); if (resource.isUsed()) { return; } if (resource.getState() == State.SUCCESS) { startSaveCredentials(mHandler.getCurrentUser(), null, resource.getValue()); } else { Exception e = resource.getException(); if (!FlowUtils.handleError(AuthMethodPickerActivity.this, e) && e.getLocalizedMessage() != null) { Toast.makeText(AuthMethodPickerActivity.this, R.string.fui_error_unknown, Toast.LENGTH_SHORT).show(); } } } }); }
public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObjectProxy> cache) { if (((RealmObject) object).realm != null && ((RealmObject) object).realm.threadId != realm.threadId) { throw new IllegalArgumentException( "Objects belonging to Realm instances in other threads cannot be copied into this Realm instance."); } if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath())) { return object; } return copy(realm, object, update, cache); }
public QName(final String namespaceURI, final String localPart, final String prefix) { if (Objects.isNull(namespaceURI)) { setNamespaceURI(XMLConstants.NULL_NS_URI); } else { setNamespaceURI(namespaceURI); } if (Objects.isNull(localPart)) { throw new IllegalArgumentException("local part cannot be \"null\" when creating a QName"); } setLocalPart(localPart); if (Objects.isNull(prefix)) { throw new IllegalArgumentException("prefix cannot be \"null\" when creating a QName"); } setPrefix(prefix); setKey(toString()); String retrievedPrefix = getPrefix(); final String usedPrefix = (retrievedPrefix == null || retrievedPrefix.isEmpty()) ? "" : retrievedPrefix + ":"; final String string = "{" + getNamespaceURI() + "}" + usedPrefix + getLocalPart(); setString(string); }
protected Deconvolution2D(BaseConvBuilder<?> builder) { super(builder); this.hasBias = builder.hasBias; this.convolutionMode = builder.convolutionMode; this.dilation = builder.dilation; if (builder.kernelSize.length != 2) throw new IllegalArgumentException("Kernel size of should be rows x columns (a 2d array)"); this.kernelSize = builder.kernelSize; if (builder.stride.length != 2) throw new IllegalArgumentException("Stride should include stride for rows and columns (a 2d array)"); this.stride = builder.stride; if (builder.padding.length != 2) throw new IllegalArgumentException("Padding should include padding for rows and columns (a 2d array)"); this.padding = builder.padding; this.cudnnAlgoMode = builder.cudnnAlgoMode; this.cudnnFwdAlgo = builder.cudnnFwdAlgo; this.cudnnBwdFilterAlgo = builder.cudnnBwdFilterAlgo; this.cudnnBwdDataAlgo = builder.cudnnBwdDataAlgo; initializeConstraints(builder); }
private static void getPackageFragmentRootContainers(IRuntimeClasspathEntry entry, List<ISourceContainer> containers) { IJavaModel model = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()); IPath entryPath = entry.getPath(); boolean found = false; try { IJavaProject[] jps = model.getJavaProjects(); for (int i = 0; i < jps.length; i++) { IJavaProject jp = jps[i]; IProject p = jp.getProject(); if (p.isOpen()) { IPackageFragmentRoot[] allRoots = jp.getPackageFragmentRoots(); for (int j = 0; j < allRoots.length; j++) { IPackageFragmentRoot root = allRoots[j]; if (root.getPath().equals(entryPath) && isSourceAttachmentEqual(root, entry)) { PackageFragmentRootSourceContainer container = new PackageFragmentRootSourceContainer(root); if (!containers.contains(container)) { containers.add(container); found = true; break; } } } } } } catch (JavaModelException e) { LaunchingPlugin.log(e); } if (!found) { tryToAddSourceAttachment(entry, containers); } }
private <T> T executeCall(String methodName, Class<T> returnType, Object[] params) throws ESException { if (client == null) { throw new ConnectionException(ConnectionManager.REMOTE); } if (Configuration.getClientBehavior().getChangePackageFragmentSize().isPresent()) { for (int i = 0; i < params.length; i++) { final Object param = params[i]; if (param instanceof AbstractChangePackage && !ChangePackageProxy.class.isInstance(param)) { params[i] = fragmentChangePackage( ESCollections.find(params, SessionId.class), ESCollections.find(params, ProjectId.class), AbstractChangePackage.class.cast(param)); } } } try { T result = (T) client.execute(serverInterface + "." + methodName, params); if (result instanceof Object[]) { final Object[] objects = (Object[]) result; final Optional<SessionId> maybeSession = ESCollections.find(params, SessionId.class); for (int i = 0; i < objects.length; i++) { final Object item = objects[i]; if (ChangePackageProxy.class.isInstance(item)) { objects[i] = aggregateChangePackageFragments((ChangePackageProxy) item, maybeSession); } } result = (T) objects; } return result; } catch (final XmlRpcException e) { if (e.getCause() instanceof ESException) { throw (ESException) e.getCause(); } else if (e.linkedException instanceof SAXException && ((SAXException) e.linkedException).getException() instanceof SerializationException) { final SerializationException serialE = (SerializationException) ((SAXException) e.linkedException) .getException(); throw new org.eclipse.emf.emfstore.internal.server.exceptions.SerializationException(serialE); } else { throw new ConnectionException(ConnectionManager.REMOTE + e.getMessage(), e); } } }
public void test() throws IOException { Configuration cfg = new Configuration(); for (Class<?> cl : Domain.classes) { cfg.addAnnotatedClass(cl); } HibernateDomainExporter exporter = new HibernateDomainExporter(folder.getRoot(), cfg); exporter.execute(); File origRoot = new File("../querydsl-jpa/target/generated-test-sources/java"); Set<File> files = exporter.getGeneratedFiles(); assertFalse(files.isEmpty()); for (File file : files) { String path = file.getAbsolutePath().replace( folder.getRoot().getAbsolutePath(), origRoot.getAbsolutePath()); String reference = Files.toString(new File(path), Charsets.UTF_8); String content = Files.toString(file, Charsets.UTF_8); try { assertEquals(file.getPath(), reference, content); } catch (Throwable e) { errors.addError(e); } } }
public String getName() { if (title == null) { if (base == null) { title = MessageFormat.format(UIText.DiffEditorInput_Title1, tip.getObjectId().abbreviate(7).name(), GitLabels.getPlainShortLabel(tip.getRepository())); } else { title = MessageFormat.format(UIText.DiffEditorInput_Title2, base.getObjectId().abbreviate(7).name(), tip.getObjectId().abbreviate(7).name(), GitLabels.getPlainShortLabel(tip.getRepository())); } } return title; }
void onContext(ValueChangeEvent<String> e) { String v = e.getValue(); int c; if (v != null && v.length() > 0) { c = Math.min(Math.max(0, Integer.parseInt(v)), 32767); contextEntireFile.setValue(false); } else if (v == null || v.isEmpty()) { c = WHOLE_FILE_CONTEXT; contextEntireFile.setValue(true); } else { return; } prefs.context(c); updateContextTimer.schedule(200); }
public void testPublish() { byte[] testBytes = {}; String testString = "Test"; when(urlService.inputStreamToByteArray(inputStream)).thenReturn(testBytes); when(facebookService.publishToFacebook(any(byte[].class), any(String.class), any(String.class), any(String.class), any(String.class))).thenReturn(testString); Response response = resource.publish(key, "Test", inputStream, contentDisposition, "photo", "Test", "Test"); String result = (String) response.getEntity(); assertEquals(response.getStatusInfo(), Response.Status.OK); assertEquals(result, "Test"); }
public Response createBranchWithId(long branchUuid, NewBranch data) { setUpHttpHeaders(); if (branchUuid <= 0) { throw new OseeWebApplicationException(Status.BAD_REQUEST, "branchUuid [%d] uuid must be > 0", branchUuid); } CreateBranchData createData = new CreateBranchData(); createData.setUuid(branchUuid); createData.setName(data.getBranchName()); createData.setBranchType(data.getBranchType()); createData.setCreationComment(data.getCreationComment()); createData.setUserArtifact(getArtifactById(COMMON_ID, data.getAuthorId())); createData.setAssociatedArtifact(getArtifactById(COMMON_ID, data.getAssociatedArtifactId())); createData.setFromTransaction(TokenFactory.createTransaction(data.getSourceTransactionId())); createData.setParentBranchUuid(getBranchUuidFromTxId(data.getSourceTransactionId())); createData.setMergeDestinationBranchId(data.getMergeDestinationBranchId()); createData.setMergeAddressingQueryId(data.getMergeAddressingQueryId()); createData.setTxCopyBranchType(data.isTxCopyBranchType()); Callable<BranchReadable> op = getBranchOps().createBranch(createData); BranchReadable result = executeCallable(op); UriInfo uriInfo = getUriInfo(); URI uri = getBranchLocation(uriInfo, result); activityLog.createEntry(BRANCH_OPERATION_TYPEID, ActivityLog.INITIAL_STATUS, String.format( "Branch Operation Create Branch {branchUUID: %s, branchName: %s accountId: %s serverId: %s clientId: %s}", branchUuid, data.getBranchName(), accountId, serverId, clientId)); return Response.created(uri).entity(asBranch(result)).build(); }
public void perform(GraphRewrite event, EvaluationContext context, XmlFileModel payload) { ClassificationService classificationService = new ClassificationService(event.getGraphContext()); ClassificationModel classificationModel = classificationService.attachClassification(event, context, payload, IssueCategoryRegistry.MANDATORY, "WebSphere WS Binding", "WebSphere Webservice Binding XML Deployment Descriptor. \n" + "This deployment descriptor extension is IBM-specific and it needs to be migrated to JBossWS. \n" + "JBossWS implements the latest JAX-WS specification, which users can reference for any vendor-agnostic web service usage need. \n" + "You can migrate deployment descriptors following the links below. \n"); classificationModel.setEffort(3); GraphContext graphContext = event.getGraphContext(); LinkService linkService = new LinkService(graphContext); LinkModel documentationEAP6Link = linkService.create(); documentationEAP6Link.setDescription("JAX-WS Web Services (EAP 6)"); documentationEAP6Link.setLink( "<LINK_0>"); classificationService.attachLink(classificationModel, documentationEAP6Link); LinkModel documentationEAP7Link = linkService.create(); documentationEAP7Link.setDescription("Developing JAX-WS Web Services (EAP 7)"); documentationEAP7Link.setLink( "<LINK_2>"); classificationService.attachLink(classificationModel, documentationEAP7Link); LinkModel documentationCommunityLink = linkService.create(); documentationCommunityLink.setDescription("JBossWS configuration (community documentation)"); documentationCommunityLink.setLink("<LINK_1>"); classificationService.attachLink(classificationModel, documentationCommunityLink); TechnologyTagService technologyTagService = new TechnologyTagService(event.getGraphContext()); technologyTagService.addTagToFileModel(payload, "WebSphere WS Binding", TechnologyTagLevel.IMPORTANT); }
private void growup() { if (values.length == capacity()) { throw new IllegalStateException("This matrix can't grow up."); } int c = rows * columns < 0 ? Integer.MAX_VALUE : rows * columns; int capacity = Math.min(c, (cardinality * 3) / 2 + 1); double $values[] = new double[capacity]; int $columnIndices[] = new int[capacity]; System.arraycopy(values, 0, $values, 0, cardinality); System.arraycopy(columnIndices, 0, $columnIndices, 0, cardinality); values = $values; columnIndices = $columnIndices; }
protected void executeQueryCommand() { List<Disk> allDiskAndSnapshots = diskDao.getAllFromDisksIncludingSnapshots(getUserID(), getParameters().isFiltered()); HashMap<UUID, DiskImage> activeDisks = new HashMap<>(); HashMap<UUID, List<DiskImage>> disksLeftForAggregate = new HashMap<>(); List<Disk> result = new ArrayList<>(); allDiskAndSnapshots.stream() .filter(disk -> { if (disk.isOvfStore()) { result.add(disk); return false; } return true; }) .filter(disk -> { if (disk instanceof LunDisk) { result.add(disk); return false; } return true; }) .map(diskImage -> (DiskImage) diskImage) .forEach(diskImage -> { UUID imageId = diskImage.getId().getUuid(); if (diskImage.getActive()) { activeDisks.put(imageId, diskImage); if (disksLeftForAggregate.containsKey(imageId)) { activeDisks.get(imageId).getSnapshots().addAll(disksLeftForAggregate.get(imageId)); disksLeftForAggregate.remove(imageId); } } else { if (activeDisks.containsKey(imageId)) { activeDisks.get(imageId).getSnapshots().add(diskImage); } else if (disksLeftForAggregate.containsKey(imageId)) { disksLeftForAggregate.get(imageId).add(diskImage); } else { List<DiskImage> newDiskImageList = new ArrayList<>(); newDiskImageList.add(diskImage); disksLeftForAggregate.put(imageId, newDiskImageList); } } }); result.addAll(activeDisks.values().stream().collect(Collectors.toList())); getQueryReturnValue().setReturnValue(result); }
int blockPlayerWin() { int equalCount = 0; int emptyI = 0, emptyJ = 0; int winCombinationsNumber = fieldSize * 2 + 2; for (int k = 0; k < winCombinationsNumber; k++) { equalCount = 0; for (int i = 0; i < fieldSize; i++) for (int j = 0; j < fieldSize; j++) { if (fieldArray[i][j] == playerMark && (getWinCombination(k, i, j) == 1)) { equalCount++; } if ((fieldArray[i][j] == EMPTY_MARK) && (getWinCombination(k, i, j) == 1)) { emptyI = i; emptyJ = j; } if ((fieldArray[i][j] == aIMark) && (getWinCombination(k, i, j) == 1)) { j = fieldSize; i = fieldSize; equalCount = 0; } } if (equalCount == (fieldSize - 1)) { return (emptyI * fieldSize + emptyJ); } } return NOTHING_TO_PREVENT; }
public ConnectionPoolConfig(VerifiableProperties verifiableProperties) { connectionPoolReadBufferSizeBytes = verifiableProperties.getIntInRange("connectionpool.read.buffer.size.bytes", 1048576, 1, 1024 * 1024 * 1024); connectionPoolWriteBufferSizeBytes = verifiableProperties.getIntInRange("connectionpool.write.buffer.size.bytes", 1048576, 1, 1024 * 1024 * 1024); connectionPoolReadTimeoutMs = verifiableProperties.getIntInRange("connectionpool.read.timeout.ms", 1500, 1, 100000); connectionPoolConnectTimeoutMs = verifiableProperties.getIntInRange("connectionpool.connect.timeout.ms", 800, 1, 100000); connectionPoolMaxConnectionsPerPortPlainText = verifiableProperties.getIntInRange("connectionpool.max.connections.per.port.plain.text", 5, 1, 20); connectionPoolMaxConnectionsPerPortSSL = verifiableProperties.getIntInRange("connectionpool.max.connections.per.port.ssl", 2, 1, 20); }
private static File asTemp(InputStream in, String prefix, String suffix, File dir) throws IOException { File tmp = File.createTempFile(prefix, suffix, dir); boolean keep = false; try { FileOutputStream out = new FileOutputStream(tmp); try { byte[] data = new byte[8192]; int n; while ((n = in.read(data)) > 0) { out.write(data, 0, n); } keep = true; return tmp; } finally { out.close(); } } finally { if (!keep) { tmp.delete(); } } }
public void writeTo(final Object data, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException { InputStream templateStream = null; try { String xslName = "/" + type.getSimpleName() + "AsPdf.xsl"; templateStream = type.getResourceAsStream(xslName); if (templateStream != null) { StreamSource transformSource = new StreamSource(templateStream); Method factoryMethod = null; for (Method currentMethod : objectFactory.getClass().getDeclaredMethods()) { Class<?>[] parameterTypes = currentMethod.getParameterTypes(); if (parameterTypes.length == 1 && parameterTypes[0] == type) { factoryMethod = currentMethod; break; } } if (data != null && factoryMethod != null) { JAXBElement<?> element = (JAXBElement<?>) factoryMethod.invoke(objectFactory, data); Source source = new JAXBSource(jaxbContext, element); Transformer xslfoTransformer = transfact.newTransformer(transformSource); Fop fop = fopFactory.newFop(MimeConstants.MIME_PDF, foUserAgent, entityStream); Result res = new SAXResult(fop.getDefaultHandler()); xslfoTransformer.transform(source, res); } else { log.error("No profile data is available for the selected volume"); } } else { log.error("Error while generating PDF.Null InputStream"); } } catch (Exception e) { log.error("Error while generating PDF.", e); } finally { if (templateStream != null) { templateStream.close(); } } }
public void nonVmWithSameMTUAddedToNic() { Network net = createNetwork("VLanVmMtu9000"); net.setvlan_id(100); net.setMtu(9000); Network newNet = createNetwork("nonVmMtu5000"); newNet.setVmNetwork(false); newNet.setMtu(9000); mockExistingNetworks(net, newNet); VdsNetworkInterface nic = createNic("nic0", null); VdsNetworkInterface nicWithVlan = createVlan(nic.getName(), net.getvlan_id(), net.getName()); nicWithVlan.setMtu(net.getMtu()); mockExistingIfaces(nic, nicWithVlan); nic.setNetworkName(newNet.getName()); SetupNetworksHelper helper = createHelper(createParametersForNics(nic, nicWithVlan)); validateAndExpectNoViolations(helper); }
public Mono<MsalToken> authenticateWithUsernamePassword(TokenRequestContext request, String username, String password) { return Mono.fromFuture(() -> getPublicClientApplication(false).acquireToken( UserNamePasswordParameters.builder(new HashSet<>(request.getScopes()), username, password.toCharArray()) .build())) .onErrorResume(t -> Mono.error(new ClientAuthenticationException("Failed to acquire token with username " + "and password", null, t))).map(ar -> new MsalToken(ar, options)); }
public void enableAccelerometer(byte[] config) { BluetoothLeGattCharacteristic accEnableChar; if (this.cc2650) { try { accEnableChar = this.gattServices.get(MOVEMENT) .findCharacteristic(TiSensorTagGatt.UUID_MOV_SENSOR_ENABLE); byte[] oldConfig = accEnableChar.readValue(); Integer newConfig = ByteBuffer.wrap(config).getShort() | ByteBuffer.wrap(oldConfig).getShort(); ByteBuffer bb = ByteBuffer.allocate(2); bb.putShort(newConfig.shortValue()); accEnableChar.writeValue(bb.array()); } catch (KuraException e) { logger.error(MOV_ERROR_MESSAGE, e); } } else { try { accEnableChar = this.gattServices.get(ACCELEROMETER) .findCharacteristic(TiSensorTagGatt.UUID_ACC_SENSOR_ENABLE); accEnableChar.writeValue(config); } catch (KuraException e) { logger.error("Accelerometer enable failed", e); } } }
public void editAggregateProvidersAttributesTest() throws Exception { String provider1name = randomAlphanumeric(5) + "_1", provider2name = randomAlphanumeric(5) + "_2", provider3name = randomAlphanumeric(5) + "_3", aggregateProvidersName = randomAlphanumeric(5); Address provider1address = elyOps.getElytronAddress(PROVIDER_LOADER, provider1name), provider2address = elyOps.getElytronAddress(PROVIDER_LOADER, provider2name), provider3address = elyOps.getElytronAddress(PROVIDER_LOADER, provider3name), aggregateProvidersAddress = elyOps.getElytronAddress(AGGREGATE_PROVIDERS, aggregateProvidersName); page.navigateToApplication().selectResource(AGGREGATE_PROVIDERS_LABEL); try { ops.add(provider1address).assertSuccess(); ops.add(provider2address).assertSuccess(); ops.add(provider3address).assertSuccess(); ops.add(aggregateProvidersAddress, Values.of(PROVIDERS, new ModelNodeListBuilder() .addNode(new ModelNode(provider1name)) .addNode(new ModelNode(provider2name)).build())); page.navigateToApplication().selectResource(AGGREGATE_PROVIDERS_LABEL).getResourceManager() .selectByName(aggregateProvidersName); page.switchToConfigAreaTab(ATTRIBUTES_LABEL); new ConfigChecker.Builder(client, aggregateProvidersAddress).configFragment(page.getConfigFragment()) .editAndSave(TEXT, PROVIDERS, provider2name + "\n" + provider3name).verifyFormSaved() .verifyAttribute(PROVIDERS, new ModelNodeListBuilder() .addNode(new ModelNode(provider2name)) .addNode(new ModelNode(provider3name)).build()); } finally { ops.removeIfExists(aggregateProvidersAddress); ops.removeIfExists(provider1address); ops.removeIfExists(provider2address); ops.removeIfExists(provider3address); adminOps.reloadIfRequired(); } }
protected File findPom(String side, String version, File json) throws IOException { File pom = cache("versions", version, side + ".pom"); HashStore cache = new HashStore(this.cache).load(cache("versions", version, side + ".pom.input")); if ("client".equals(side)) { cache.add(json); } if (!cache.isSame() || !pom.exists()) { POMBuilder builder = new POMBuilder(GROUP, side, version); if ("client".equals(side)) { VersionJson meta = Utils.loadJson(json, VersionJson.class); for (VersionJson.Library lib : meta.libraries) { if (lib.downloads.classifiers != null) { if (lib.downloads.classifiers.containsKey("test")) { builder.dependencies().add(lib.name, "test").withClassifier("test"); } if (lib.natives != null && lib.natives.containsKey(CURRENT_OS) && !lib.getArtifact().getName().contains("java-objc-bridge")) { builder.dependencies().add(lib.name, "runtime").withClassifier(lib.natives.get(CURRENT_OS)); } } else { builder.dependencies().add(lib.name, "compile"); } } } else { builder.dependencies().add(GROUP + ":" + side + ":" + version, "compile").withClassifier("extra"); } builder.dependencies().add(GROUP + ":" + side + ":" + version, "compile").withClassifier("data"); builder.dependencies().add("com.google.code.findbugs:jsr305:3.0.1", "compile"); String ret = builder.tryBuild(); if (ret == null) { return null; } FileUtils.writeByteArrayToFile(pom, ret.getBytes()); cache.save(); Utils.updateHash(pom); } return pom; }
@Override public int selectString(Options options) throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p != PEEKED_DOUBLE_QUOTED) { return -1; } int result = source.select(options.doubleQuoteSuffix); if (result == -1) { String nextString = nextString(); for (int i = 0, size = options.strings.length; i < size; i++) { if (nextString.equals(options.strings[i])) { result = i; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; break; } } if (result == -1) { peeked = PEEKED_BUFFERED; peekedString = nextString; pathIndices[stackSize - 1]--; } } else { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } return result; }
public void updateMessage() throws Exception { assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))) .isEqualTo(RefUpdate.Result.NEW); Optional<ChangeEdit> edit = editUtil.byChange(change); try { modifier.modifyMessage( edit.get(), edit.get().getEditCommit().getFullMessage()); fail("InvalidChangeOperationException expected"); } catch (UnchangedCommitMessage ex) { assertThat(ex.getMessage()).isEqualTo( "New commit message cannot be same as existing commit message"); } String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey()); assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo( RefUpdate.Result.FORCED); edit = editUtil.byChange(change); assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg); editUtil.publish(edit.get()); assertThat(editUtil.byChange(change).isPresent()).isFalse(); ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION); assertThat(info.revisions.get(info.currentRevision).commit.message) .isEqualTo(msg); }
private long getCowVirtualSize(String id) throws IOException { byte[] imgContent = new byte[72]; ImageDownload downloadImage = getGlanceClient().images().download(id).execute(); try { int bytesRead = downloadImage.getInputStream().read(imgContent, 0, imgContent.length); if (bytesRead != imgContent.length) { throw new RuntimeException("Unable to read image header: " + bytesRead); } } finally { downloadImage.getInputStream().close(); } ByteBuffer b = ByteBuffer.wrap(imgContent); if (b.getInt() == 0x514649fb && b.getInt() == 2) { b.position(24); return b.getLong(); } throw new RuntimeException("Unable to recognize QCOW2 format"); }
public void swap(INDArray x, INDArray y) { if (Nd4j.getExecutioner().getProfilingMode() == OpExecutioner.ProfilingMode.ALL) OpProfiler.getInstance().processBlasCall(false, x, y); if(x.isSparse() || y.isSparse()) { Nd4j.getSparseBlasWrapper().level1().swap(x, y); } if (x.data().dataType() == DataBuffer.Type.DOUBLE) { DefaultOpExecutioner.validateDataType(DataBuffer.Type.DOUBLE, x, y); dswap(x.length(), x, BlasBufferUtil.getBlasStride(x), y, BlasBufferUtil.getBlasStride(y)); } else { DefaultOpExecutioner.validateDataType(DataBuffer.Type.FLOAT, x, y); sswap(x.length(), x, BlasBufferUtil.getBlasStride(x), y, BlasBufferUtil.getBlasStride(y)); } }
public static void openConsole(File file) throws IOException { if (file == null) { return; } String absolutePath = file.toPath().toAbsolutePath().getParent().toString(); boolean usingDefault = Globals.prefs.getBoolean(JabRefPreferences.USE_DEFAULT_CONSOLE_APPLICATION); if (usingDefault) { NATIVE_DESKTOP.openConsole(absolutePath); } else { String command = Globals.prefs.get(JabRefPreferences.CONSOLE_COMMAND); command = command.trim(); if (!command.isEmpty()) { command = command.replaceAll("\\s+", " "); String[] subcommands = command.split(" "); String commandLoggingText = command.replace("%DIR", absolutePath); JabRefGUI.getMainFrame().getDialogService().notify(Localization.lang("Executing command \"%0\"...", commandLoggingText)); LOGGER.info("Executing command \"" + commandLoggingText + "\"..."); try { new ProcessBuilder(subcommands).start(); } catch (IOException exception) { LOGGER.error("Open console", exception); JOptionPane.showMessageDialog(null, Localization.lang("Error occured while executing the command \"%0\".", commandLoggingText), Localization.lang("Open console") + " - " + Localization.lang("Error"), JOptionPane.ERROR_MESSAGE); } } } }
private ISYBindingConfig parseConfig(final Item item, final String bindingConfig) throws BindingConfigParseException { ISYNodeType type; String controller = null; String address = null; ISYControl command = null; if (item instanceof GroupItem) { type = ISYNodeType.GROUP; } else if (item instanceof ContactItem) { type = ISYNodeType.CONTACT; } else if (item instanceof NumberItem) { type = ISYNodeType.NUMBER; } else if (item instanceof StringItem) { type = ISYNodeType.STRING; } else if (item instanceof DimmerItem) { type = ISYNodeType.DIMMER; } else if (item instanceof DateTimeItem) { type = ISYNodeType.HEARTBEAT; } else { type = ISYNodeType.SWITCH; } String[] arr = bindingConfig.split(","); for (String str : arr) { String[] pair = str.split("="); String key = pair[0]; String value = pair[1]; switch (key) { case "ctrl": controller = value.replace('.', ' '); break; case "addr": address = value.replace('.', ' '); break; case "type": if ("thermostat".equalsIgnoreCase(value)) { type = ISYNodeType.THERMOSTAT; } if ("lock".equalsIgnoreCase(value)) { type = ISYNodeType.LOCK; } if ("heartbeat".equalsIgnoreCase(value)) { type = ISYNodeType.HEARTBEAT; } break; case "cmd": try { command = ISYControl.valueOf(value.toUpperCase()); } catch (IllegalArgumentException ie) { throw new BindingConfigParseException("Unsupported cmd " + value.toString()); } break; } } if (address == null) { address = controller; } return new ISYBindingConfig(item, type, controller, address, command); }
private TestResult runAll4x() throws Exception { List<String> testClassNames = new ArrayList<>(); Files.walk(Paths.get(projectPath, "target", "test-classes")).forEach(filePath -> { if (Files.isRegularFile(filePath) && filePath.toString().toLowerCase().endsWith(".class")) { String path = Paths.get(projectPath, "target", "test-classes").relativize(filePath).toString(); String className = path.replace('/', '.'); className = className.replace('\\', '.'); className = className.substring(0, className.length() - 6); testClassNames.add(className); } }); List<Class> testableClasses = new ArrayList<>(); for (String className : testClassNames) { Class<?> clazz = Class.forName(className, false, projectClassLoader); if (isTestable4x(clazz)) { testableClasses.add(clazz); } } return run4xTestClasses(testableClasses.toArray(new Class[testableClasses.size()])); }
private Phenotype updatePhenotype( final Integer observationId, final Integer categoricalValueId, final String value, final Boolean draftMode) { final PhenotypeDao phenotypeDao = this.daoFactory.getPhenotypeDAO(); final Phenotype phenotype = phenotypeDao.getById(observationId); if (draftMode) { phenotype.setDraftValue(value); phenotype.setDraftCValueId(categoricalValueId == null || categoricalValueId == 0 ? null : categoricalValueId); } else { phenotype.setValue(value); phenotype.setcValue(categoricalValueId == null || categoricalValueId == 0 ? null : categoricalValueId); } final Integer observableId = phenotype.getObservableId(); this.resolveObservationStatus(observableId, phenotype); phenotype.setChanged(true); phenotypeDao.update(phenotype); return phenotype; }
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) { final Pair<List<Guid>, Guid> migrationRule = super.balance(cluster, hosts, parameters, messages); List<VDS> allHosts = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(cluster.getId()); Pair<VDS, VDSStatus> action = evaluatePowerManagementSituation( getDownHosts(allHosts, parameters), getMaintenanceHosts(allHosts, parameters), getEmptyHosts(allHosts, parameters), parameters ); if (action != null) processPmAction(action); return migrationRule; }
public LowLevelHttpResponse execute() throws IOException { if (getStreamingContent() != null) { Preconditions.checkArgument( request instanceof HttpEntityEnclosingRequest, "Apache HTTP client does not support %s requests with content.", request.getRequestLine().getMethod()); ContentEntity entity = new ContentEntity(getContentLength(), getStreamingContent()); entity.setContentEncoding(getContentEncoding()); entity.setContentType(getContentType()); if (getContentLength() == -1) { entity.setChunked(true); } ((HttpEntityEnclosingRequest) request).setEntity(entity); } return new ApacheHttpResponse(request, httpClient.execute(request)); }
public void onMessage(Message message) { try { log.infof("onMessage received message: %s '%s'", message, ((TextMessage) message).getText()); if(checker.getRolledback() > 0) { log.infof("Discarding message '%s' as onMessage called for second time", message); return; } final Destination replyTo = message.getJMSReplyTo(); if (replyTo == null) { throw new RuntimeException("ReplyTo info in message was not specified" + " and bean does not know where to reply to"); } TxTestUtil.enlistTestXAResource(tm.getTransaction()); try ( JMSContext context = factory.createContext() ) { context.createProducer() .setJMSCorrelationID(message.getJMSMessageID()) .send(replyTo, REPLY_PREFIX + ((TextMessage) message).getText()); } TxTestUtil.waitForTimeout(tm); } catch (Exception e) { throw new RuntimeException("onMessage method execution failed", e); } }
private Object convertValue(Object value, Type type) { if (value == null) { return null; } if (BOOLEAN.equals(type) || Varchars.isVarcharType(type)) { return value; } if (BIGINT.equals(type)) { return ((Number) value).longValue(); } if (INTEGER.equals(type)) { return ((Number) value).intValue(); } if (DOUBLE.equals(type)) { return ((Number) value).doubleValue(); } if (DATE.equals(type)) { return value; } throw new AssertionError("unhandled type: " + type); }
public void getCallsListUsingSorting() { JsonObject response1 = RestcommCallsTool.getInstance().getCalls(deploymentUrl.toString(), adminAccountSid, adminAuthToken, 0, 10, "date_created:asc", true); assertTrue(((JsonObject)response1.get("calls").getAsJsonArray().get(0)).get("date_created").getAsString().equals("Fri, 5 Jul 2013 22:15:53 +0300")); JsonObject response2 = RestcommCallsTool.getInstance().getCalls(deploymentUrl.toString(), adminAccountSid, adminAuthToken, 0, 10, "date_created", true); assertTrue(((JsonObject)response2.get("calls").getAsJsonArray().get(0)).get("date_created").getAsString().equals("Tue, 31 May 2016 16:20:22 +0300")); JsonObject response3 = RestcommCallsTool.getInstance().getCalls(deploymentUrl.toString(), adminAccountSid, adminAuthToken, 0, 10, "date_created:desc", true); assertTrue(((JsonObject)response3.get("calls").getAsJsonArray().get(0)).get("date_created").getAsString().equals("Tue, 31 May 2016 16:20:22 +0300")); JsonObject response4 = RestcommCallsTool.getInstance().getCalls(deploymentUrl.toString(), adminAccountSid, adminAuthToken, 0, 10, null, true); assertTrue(((JsonObject)response4.get("calls").getAsJsonArray().get(0)).get("date_created").getAsString().equals("Tue, 31 May 2016 16:20:22 +0300")); try { RestcommCallsTool.getInstance().getCalls(deploymentUrl.toString(), adminAccountSid, adminAuthToken, 0, 10, ":asc", true); } catch (UniformInterfaceException e) { assertTrue(e.getResponse().getStatus() == BAD_REQUEST.getStatusCode()); } try { RestcommCallsTool.getInstance().getCalls(deploymentUrl.toString(), adminAccountSid, adminAuthToken, 0, 10, "start_time:invalid", true); } catch (UniformInterfaceException e) { assertTrue(e.getResponse().getStatus() == BAD_REQUEST.getStatusCode()); } }
public int getInt(int length, boolean signed) { if (length == 0) { return 0; } if (!canRead(length)) { throw new BufferOverflowException(); } int val = 0; boolean gotIt = false; if (this.pos % BitBuffer.BIT_CHAR == 0) { switch (length) { case BitBuffer.BIT_CHAR: val = this.buf.get((int) (this.pos / 8)); if (!signed) { val = val & 0xff; } gotIt = true; break; case BitBuffer.BIT_SHORT: val = this.buf.getShort((int) (this.pos / 8)); if (!signed) { val = val & 0xffff; } gotIt = true; break; case BitBuffer.BIT_INT: val = this.buf.getInt((int) (this.pos / 8)); gotIt = true; break; default: break; } } if (!gotIt) { if (this.byteOrder == ByteOrder.LITTLE_ENDIAN) { val = getIntLE(this.pos, length, signed); } else { val = getIntBE(this.pos, length, signed); } } this.pos += length; return val; }
private void visitClassOrInterface(String name, FunctionType ftype) { final boolean emitInstance = !ftype.isInterface(); if (emitInstance) { emit("class"); emit(name); visitTemplateTypes(ftype); emit("extends"); emit(name + INSTANCE_CLASS_SUFFIX); visitTemplateTypes(ftype); emit("{"); indent(); emitBreak(); visitProperties(ftype, true); unindent(); emit("}"); emitBreak(); } if (ftype.isConstructor()) { emit("class"); } else if (ftype.isInterface()) { emit("interface"); } else { checkState(false, "Unexpected function type " + ftype); } emit(emitInstance ? name + INSTANCE_CLASS_SUFFIX : name); visitTemplateTypes(ftype); if (ftype.getExtendedInterfacesCount() > 0) { emit("extends"); Iterator<ObjectType> it = ftype.getExtendedInterfaces().iterator(); emitCommaSeparatedInterfaces(it); } ObjectType superType = getSuperType(ftype); if (superType != null) { emit("extends"); if (isPrivate(superType.getJSDocInfo())) { emit(Constants.INTERNAL_NAMESPACE + ".PrivateClass"); } else { Visitor<Void> visitor = new ExtendsImplementsTypeVisitor( emitInstance && !isDefinedInPlatformExterns(superType)); superType.visit(visitor); } } Iterator<ObjectType> it = ftype.getOwnImplementedInterfaces().iterator(); if (it.hasNext()) { emit("implements"); emitCommaSeparatedInterfaces(it); } boolean implementsIArrayLike = any(ftype.getOwnImplementedInterfaces(), IARRAYLIKE_PREDICATE); visitObjectType(ftype, ftype.getPrototype(), ftype.isDict() || implementsIArrayLike); }
public void startExec(String execId, MessageProcessor<LogMessage> execOutputProcessor) throws IOException { final List<Pair<String, ?>> headers = new ArrayList<>(2); headers.add(Pair.of("Content-Type", "application/json")); final ExecStart execStart = new ExecStart().withDetach(execOutputProcessor == null); final String entity = JsonHelper.toJson(execStart, FIRST_LETTER_LOWERCASE); headers.add(Pair.of("Content-Length", entity.getBytes().length)); try (DockerConnection connection = openConnection(dockerDaemonUri).method("POST") .path("/exec/" + execId + "/start") .headers(headers) .entity(entity)) { final DockerResponse response = connection.request(); final int status = response.getStatus(); if (status / 100 != 2) { throw new DockerException(getDockerExceptionMessage(response), status); } if (status != 204 && execOutputProcessor != null) { try (InputStream responseStream = response.getInputStream()) { new LogMessagePumper(responseStream, execOutputProcessor).start(); } } } }
private void updateSnapshotConfigWithoutImage(Guid imageGroupToRemove) { List<DiskImage> snapshotDisks = getDiskImageDao().getAllSnapshotsForImageGroup(imageGroupToRemove); for (DiskImage snapshotDisk : snapshotDisks) { NGuid vmSnapshotId = snapshotDisk.getvm_snapshot_id(); if (vmSnapshotId != null && !Guid.Empty.equals(vmSnapshotId.getValue())) { try { lockSnapshotWithWait(vmSnapshotId.getValue()); final Snapshot updated = prepareSnapshotConfigWithoutImageSingleImage(vmSnapshotId.getValue(), snapshotDisk.getImageId()); if (updated != null) { TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() { @Override public Object runInTransaction() { getSnapshotDao().update(updated); return null; } }); } } finally { freeSnapshotLock(); } } } }
public void MercuryCuratedNavigationTest_004_navigateThroughDifferentUrl() { CuratedContentPageObject section = new CuratedContentPageObject(driver); String expectedUrl = urlBuilder.getUrlForPathWithoutWiki(Configuration.getWikiName(), MercurySubpages.CC_CATEGORY_TEMPLATES); String testUrl = expectedUrl; section.openWikiPage(testUrl); section.waitForLoadingSpinnerToFinish(); Assertion.assertUrlEqualToCurrentUrl(driver, expectedUrl); expectedUrl = urlBuilder.getUrlForPathWithoutWiki(Configuration.getWikiName(), MercurySubpages.CC_SECTION_CATEGORIES); testUrl = expectedUrl; section.openWikiPage(testUrl); section.waitForLoadingSpinnerToFinish(); Assertion.assertUrlEqualToCurrentUrl(driver, expectedUrl); expectedUrl = urlBuilder.getUrlForPath(Configuration.getWikiName(), MercurySubpages.CC_MAIN_PAGE); testUrl = urlBuilder.getUrlForPathWithoutWiki(Configuration.getWikiName(), MercurySubpages.CC_EMPTY_CATEGORY); section.openWikiPage(testUrl); section.waitForLoadingSpinnerToFinish(); Assertion.assertUrlEqualToCurrentUrl(driver, expectedUrl); expectedUrl = urlBuilder.getUrlForPath(Configuration.getWikiName(), MercurySubpages.CC_MAIN_PAGE); testUrl = urlBuilder.getUrlForPathWithoutWiki(Configuration.getWikiName(), MercurySubpages.CC_NOT_EXISTING_SECTION); section.openWikiPage(testUrl); section.waitForLoadingSpinnerToFinish(); MercuryAlertComponentObject mercuryError = new MercuryAlertComponentObject( driver, Mercury.AlertMessage.NOT_EXISTING_SECTION); Assertion.assertTrue(mercuryError.isAlertMessageVisible()); Assertion.assertUrlEqualToCurrentUrl(driver, expectedUrl); }
public void testScenarios() throws IOException, DockerCertificateException { String testResourcesPath = getClass().getClassLoader().getResource(".").getPath(); TestScenariosFinder testScenariosFinder = new TestScenariosFinder(testResourcesPath); List<TestScenario> testScenarios = testScenariosFinder.getScenarios(); TestScenarioRunner caseRunner = new TestScenarioRunner(ProjectVersion.currentVersion(), 9080); int successfulScenarios = 0; int failedScenarios = 0; for (TestScenario testScenario: testScenarios) { if (testScenario.enabledTests() == 0) { continue; } int successfulTestCases = caseRunner.run(testScenario); if (successfulTestCases == testScenario.enabledTests()) { System.out.println("\nScenario success: " + testScenario + "\n"); System.out.println("Number of successful test cases: " + successfulTestCases); successfulScenarios++; } else { System.out.println("\nScenario failed: " + testScenario + "\n"); System.out.println("Number of failed test cases: " + (testScenario.enabledTests() - successfulTestCases)); failedScenarios++; } } System.out.println("\n\nScenarios results:\nSuccessful: " + successfulScenarios + ", Failed: " + failedScenarios + "\n\n"); }
public boolean handleNotificationFor(String ipAddress, String payload) { if (isNotificationRejectedFromIpAddress(ipAddress)) { logger.error("{} notification received from ip '{}' which is not in domain '{}'", gatewayName(), ipAddress, notificationDomain()); return false; } WorldpayNotification notification; try { logger.info("Parsing {} notification", gatewayName()); logger.debug("Payload: {}", payload); notification = XMLUnmarshaller.unmarshall(payload, WorldpayNotification.class); logger.info("Parsed {} notification: {}", gatewayName(), notification); } catch (XMLUnmarshallerException e) { logger.error("{} notification parsing failed: {}", gatewayName(), e.toString()); return true; } if (isIgnored(notification)) { logger.info("{} notification {} ignored", gatewayName(), notification); return true; } if (isTransactionIdBlank(notification)) { logger.warn("{} notification {} failed verification because it has no transaction ID", gatewayName(), notification); return true; } Optional<ChargeEntity> optionalChargeEntity = chargeDao.findByProviderAndTransactionId(gatewayName(), notification.getTransactionId()); if (!optionalChargeEntity.isPresent()) { logger.info("{} notification {} could not be evaluated (associated charge entity not found)", gatewayName(), notification); return false; } if (isCaptureNotification(notification)) { chargeNotificationProcessor.invoke(notification.getTransactionId(), optionalChargeEntity.get(), CAPTURED, notification.getGatewayEventDate()); } else if (isRefundNotification(notification)) { refundNotificationProcessor.invoke(getPaymentGatewayName(), newRefundStatus(notification), notification.getReference(), notification.getTransactionId()); } else { logger.error("{} notification {} unknown", gatewayName(), notification); } return true; }
private PinotExpression handleCast(CallExpression cast, Map<VariableReferenceExpression, Selection> context) { if (cast.getArguments().size() == 1) { RowExpression input = cast.getArguments().get(0); Type expectedType = cast.getType(); if (isImplicitCast(input.getType(), expectedType)) { return input.accept(this, context); } else { throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), "Non implicit casts not supported: " + cast); } } throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format("This type of CAST operator not supported. Received: %s", cast)); }
public void testPublishWithNullVideoTitle() { byte[] testBytes = {}; String testString = "Test"; when(urlService.inputStreamToByteArray(inputStream)).thenReturn(testBytes); when(facebookService.publishToFacebook(any(byte[].class), any(String.class), any(String.class), any(String.class), any(String.class))).thenReturn(testString); Response response = resource.publish(key, "Test", inputStream, contentDisposition, "photo", "Test", null); String result = (String) response.getEntity(); assertEquals(response.getStatusInfo(), Response.Status.OK); assertEquals(result, "Test"); }
public void testDeleteClientDeleteMutationPlan() throws Exception { String tableName = generateUniqueName(); String indexName = generateUniqueName(); String tagValue = "customer-delete"; String delete = "DELETE FROM " + tableName + " WHERE v1 = 'foo'"; Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES); props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue); createAndUpsertTable(tableName, indexName, props); verifyDeletePlan(delete, "ClientSelectDeleteMutationPlan", props); executeDelete(delete, props, 1); String startRowKeyForBaseTable = "1"; String startRowKeyForIndexTable = "foo"; checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue); checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null); }
public void updateDocument(String entityType, int entityId, int documentId, String name, String desc, File file) { checkViewAttached(); getMvpView().showProgressbar(true); mSubscriptions.add(mDataManagerDocument.updateDocument(entityType, entityId, documentId, name, desc, getRequestFileBody(file)) .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.io()) .subscribe(new Subscriber<DocumentRelatedResponse>() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { getMvpView().showProgressbar(false); if (e instanceof HttpException) { try { String errorMessage = ((HttpException) e).response().errorBody() .string(); getMvpView().showUpdationError(MFErrorParser .parseError(errorMessage) .getErrors().get(0).getDefaultUserMessage()); } catch (Throwable throwable) { RxJavaPlugins.getInstance().getErrorHandler().handleError(e); } } else { getMvpView().showUpdationError(e.getLocalizedMessage()); } } @Override public void onNext(DocumentRelatedResponse documentUpdateResponse) { getMvpView().showProgressbar(false); getMvpView().showDocumentUpdatedSuccessfully(documentUpdateResponse); } }) ); }
public String solveProblemForAll() { try { for (Task s : this.steps) { this.currentStep = s; serviceManager.getWorkflowService().setSolution(getSolution()); try { setCurrentStep(serviceManager.getWorkflowService().solveProblem(this.currentStep, this.solutionTask)); } catch (DataException e) { logger.error("Problem couldn't be solved: " + e); } saveStep(); } this.solution.setMessage(""); this.solutionTask = ""; AktuelleSchritteForm asf = (AktuelleSchritteForm) Helper.getManagedBeanValue("#{AktuelleSchritteForm}"); return asf.filterAll(); } catch (AuthenticationException e) { Helper.setFehlerMeldung(e.getMessage()); return ""; } }
public void onMessage(String data) { try { Map<String, Object> dataMap = objectMapper.readValue(data, new TypeReference<Map<String, Object>>() {}); String event = (String) dataMap.get("event"); if ("KEEP_ALIVE".equals(event)) { return; } String type = (String) dataMap.get("type"); if (type == null) { log.debug("type missing so ignoring message. {}", dataMap); return; } if (type.equals("authenticated")) { log.info("WebSocket connection authenticated as {} (in {})", dataMap.get("userId"), dataMap.get("orgId")); } else { String channelName = (String) dataMap.get("channel"); if (channelName != null) { TransportChannel channel = channels.get(channelName); if ((channel != null) && (!channel.isClosed())) { StreamMessage message = new StreamMessage(type, null, data); channel.offer(message); } else { log.debug("ignoring message. channel not found {}", channelName); } } } } catch (IOException ex) { log.error("failed to process messages", ex); } }
public NetworkScan requestNetworkScan(int subId, NetworkScanRequest request, Executor executor, NetworkScanCallback callback, String callingPackage) { try { ITelephony telephony = getITelephony(); if (telephony != null) { int scanId; synchronized (mScanInfo) { scanId = telephony.requestNetworkScan( subId, request, mMessenger, new Binder(), callingPackage); if (scanId == INVALID_SCAN_ID) { Rlog.e(TAG, "Failed to initiate network scan"); return null; } saveScanInfo(scanId, request, executor, callback); } return new NetworkScan(scanId, subId); } } catch (RemoteException ex) { Rlog.e(TAG, "requestNetworkScan RemoteException", ex); } catch (NullPointerException ex) { Rlog.e(TAG, "requestNetworkScan NPE", ex); } return null; }
private static ContinuousStream<Map<String, Object>> cepStatelessRulesTranslator( final ContinuousStream<Map<String, Object>> inputMap, final List<CepStatelessRule> cepStatelessRules) { final int ruleNum = cepStatelessRules.size(); for (int i = 0; i < ruleNum; i++) { final CepStatelessRule rule = cepStatelessRules.get(i); final CepAction action = rule.getAction(); final CepSink sink = action.getCepSink(); ContinuousStream<Map<String, Object>> temp = inputMap; switch (action.getCepActionType()) { case TEXT_WRITE: { switch (sink.getCepSinkType()) { case TEXT_SOCKET_OUTPUT: { temp = cepConditionTranslator(temp, rule.getCondition()); final List<Object> params = action.getParams(); final String separator = sink.getSeparator(); temp.map(new CepMapToStringFunction(params, separator)) .textSocketOutput((String)sink.getSinkConfigs().get("SOCKET_SINK_ADDRESS"), (int)sink.getSinkConfigs().get("SOCKET_SINK_PORT")); break; } case MQTT_OUTPUT: { temp = cepConditionTranslator(temp, rule.getCondition()); final List<Object> params = action.getParams(); final String separator = sink.getSeparator(); temp.map(new CepMapToStringFunction(params, separator)) .map(value -> new MqttMessage(value.getBytes())) .mqttOutput((String) sink.getSinkConfigs().get("MQTT_SINK_BROKER_URI"), (String) sink.getSinkConfigs().get("MQTT_SINK_TOPIC")); break; } default: throw new IllegalStateException("Wrong sink type!"); } break; } default: continue; } } return inputMap; }
public static void createQueue(String projectId, String locationId, String queueId) throws Exception { try (CloudTasksClient client = CloudTasksClient.create()) { String parent = LocationName.of(projectId, locationId).toString(); String queuePath = QueueName.of(projectId, locationId, queueId).toString(); Queue queue = client.createQueue(parent, Queue.newBuilder().setName(queuePath).build()); System.out.println("Queue created: " + queue.getName()); } }
public void createPartControl(Composite parent) { super.createPartControl(parent); pinPropertySheetAction.addPropertyChangeListener(new IPropertyChangeListener(){ @Override public void propertyChange(PropertyChangeEvent event) { if (IAction.CHECKED.equals(event.getProperty())) { updateContentDescription(); } } }); IMenuManager menuManager = getViewSite().getActionBars() .getMenuManager(); menuManager.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS)); menuManager.add(pinPropertySheetAction); IToolBarManager toolBarManager = getViewSite().getActionBars() .getToolBarManager(); menuManager.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS)); toolBarManager.add(pinPropertySheetAction); SaveablesList saveables = (SaveablesList) getSite().getService(ISaveablesLifecycleListener.class); if (saveables != null) { saveables.addModelLifecycleListener(saveablesTracker); } getSite().getPage().getWorkbenchWindow().getWorkbench().getHelpSystem() .setHelp(getPageBook(), IPropertiesHelpContextIds.PROPERTY_SHEET_VIEW); }
private SimRobot() { super(); nodeList.add(new FullSimRunner("Full Sim Toolbox", new LocTuple(40.441670, -79.9416362))); RobobuggyJFrame mainWindow = new RobobuggyJFrame("MainWindow", 1.0, 1.0); Gui.getInstance().addWindow(mainWindow); RobobuggyGUITabs tabs = new RobobuggyGUITabs(); mainWindow.addComponent(tabs, 0.0, 0.0, 1.0, 1.0); tabs.addTab(new MainGuiWindow(), "Home"); tabs.add(new PathPanel(), "Path Visualizer"); tabs.addTab(new ConfigurationPanel(), "Configuration"); }
public void testFilteredContent_2() throws Throwable { UserDetails user = new OAuth2TestUtils.UserBuilder("jack_bauer", "0x24") .withAuthorization(Group.FREE_GROUP_NAME, "tempRole", Permission.BACKOFFICE).build(); String accessToken = mockOAuthInterceptor(user); ResultActions result = mockMvc .perform(get("/plugins/cms/contents") .param("status", IContentService.STATUS_ONLINE) .param("sort", IContentManager.CONTENT_CREATION_DATE_FILTER_KEY) .param("direction", FieldSearchFilter.DESC_ORDER) .param("filters[0].attribute", "id") .param("filters[0].value", "EVN194") .sessionAttr("user", user) .header("Authorization", "Bearer " + accessToken)); String bodyResult = result.andReturn().getResponse().getContentAsString(); result.andExpect(status().isOk()); String expectedContentId = "EVN194"; int payloadSize = JsonPath.read(bodyResult, "$.payload.size()"); String extractedId = JsonPath.read(bodyResult, "$.payload[" + 0 + "].id"); Assert.assertEquals(expectedContentId, extractedId); }
public void deleteCacheStorageTest() { CacheStorageImpl cache = new CacheStorageImpl(); final Map<Identifier, OperatorState> queryState1= new HashMap<>(); queryState1.put(oid1, value1); cache.create(qid1, queryState1); Assert.assertEquals(value1, cache.read(qid1, oid1)); Assert.assertEquals(true, cache.delete(qid1)); Assert.assertSame(null, cache.read(qid1, oid1)); Assert.assertEquals(false, cache.delete(qid1)); Assert.assertEquals(false, cache.delete(qid2)); }
public void shouldDeleteNetworkToPublicRouterNoDeleted() throws OpenStackException, InfrastructureException { String response = "{\"ports\": [ {\"status\": \"ACTIVE\",\"name\": \"\", \"admin_state_up\": true, " + "\"network_id\": \"ID\", \"tenant_id\": \"08bed031f6c54c9d9b35b42aa06b51c0\"," + "\"device_owner\": \"compute:None\", \"binding:capabilities\": {\"port_filter\": true}, " + "\"fixed_ips\": [ {\"subnet_id\": \"ID\", \"ip_address\": \"172.31.0.3\"}]," + "\"id\": \"07fd27d2-9ce1-48f3-be83-c7d2b7041a1a\", \"security_groups\": [], \"device_id\":" + " \"dhcpfa3e6aae-2140-5176-877a-2f67684a3165-6a609412-3f04-485c-b269-b1a9b9ecb6bf\"" + "}]}"; when(openStackUtil.listPorts(any(PaasManagerUser.class), anyString())).thenReturn(response); NetworkInstance net = new NetworkInstance("router", "vdc", "region"); SubNetworkInstance subNet = new SubNetworkInstance("dd", "vdc", "region", "ID"); subNet.setIdSubNet("ID"); net.addSubNet(subNet); when(openStackUtil.deleteInterfaceToPublicRouter(any(PaasManagerUser.class), any(NetworkInstance.class), anyString())).thenReturn(response); openStackNetworkImpl.deleteNetworkToPublicRouter(claudiaData, net, REGION); }
public void requestSpace(long sessionId, long blockId, long additionalBytes) throws BlockDoesNotExistException, WorkerOutOfSpaceException, IOException { LOG.debug("requestSpace: sessionId={}, blockId={}, additionalBytes={}", sessionId, blockId, additionalBytes); try (LockResource r = new LockResource(mMetadataWriteLock)) { TempBlockMeta tempBlockMeta = mMetaManager.getTempBlockMeta(blockId); StorageDirView allocationDir = allocateSpace(sessionId, AllocateOptions.forRequestSpace(additionalBytes, tempBlockMeta.getBlockLocation())); if (allocationDir == null) { throw new WorkerOutOfSpaceException(String.format( "Can't reserve more space for block: %d under session: %d.", blockId, sessionId)); } if (!allocationDir.toBlockStoreLocation().equals(tempBlockMeta.getBlockLocation())) { throw new RuntimeException("Allocation error: location enforcement failed"); } try { mMetaManager.resizeTempBlockMeta( tempBlockMeta, tempBlockMeta.getBlockSize() + additionalBytes); } catch (InvalidWorkerStateException e) { throw Throwables.propagate(e); } } }
protected void processMultiValuedEAttribute(EAttribute eAttribute, SIRIUS processedDescription, SIRIUS currentDescription, TransformationCache cache) { Object processedValue = processedDescription.eGet(eAttribute); Object currentValue = currentDescription.eGet(eAttribute); if (currentValue instanceof Iterable<?> && processedValue instanceof Iterable<?>) { List<Object> newValue = new ArrayList<>(); Iterable<?> currentIterable = (Iterable<?>) currentValue; Iterable<?> processedIterable = (Iterable<?>) processedValue; for (Object object : currentIterable) { newValue.add(object); } for (Object object : processedIterable) { newValue.add(object); } processedDescription.eSet(eAttribute, newValue); } }
public static UUID makeUUID(byte bytes[]) { long high = 0; long low = 0; if (bytes.length < Utils.UUID_LEN) { throw new IllegalArgumentException("UUID byte field must be 16 bytes long"); } final int bitsPerByte = Byte.SIZE; int bitMask = (1 << bitsPerByte) - 1; for (int i = 0; i < bitsPerByte; i++) { low = (low << bitsPerByte) | (bytes[i + bitsPerByte] & bitMask); high = (high << bitsPerByte) | (bytes[i] & bitMask); } UUID uuid = new UUID(high, low); return uuid; }
public void verify_fallback_in_download_presigned_urls() throws Exception { AmazonServiceException firstException = new AmazonServiceException("Didn't find Object Id in bucket"); firstException.setStatusCode(HttpStatus.NOT_FOUND.value()); int bucketPoolSize = 32; int bucketKeySize = 2; ReflectionTestUtils.setField(service, "bucketPoolSize", bucketPoolSize); ReflectionTestUtils.setField(service, "bucketKeySize", bucketKeySize); ObjectURLGenerator urlGen = new AmazonURLGenerator(); ReflectionTestUtils.setField(urlGen, "s3Client", ObjectDownloadServiceStubFactory.createS3ClientForRadosGW(endpointUrl)); ReflectionTestUtils.setField(service, "urlGenerator", urlGen); when(s3Client.getObject(Mockito.any())).thenThrow(firstException); List<Part> parts = ObjectDownloadServiceStubFactory.createParts(5); ObjectSpecification os = ObjectDownloadServiceStubFactory.createObjectSpecification(objectId, ObjectKeys.getObjectKey(dataDir, objectId), 104857600); os.setParts(parts); os.setRelocated(true); ObjectDownloadService sut = spy(service); doReturn(os).when(sut).getSpecification(objectId); val objSpec = sut.download(objectId, 0, 104857600, false); Part p = objSpec.getParts().get(0); URL url = new URL(p.getUrl()); String path = url.getPath(); if (path.startsWith("/")) { path = path.substring(1, path.length() - 1); } String bucket = Splitter.on('/').trimResults().omitEmptyStrings().split(path).iterator().next(); assertEquals(dataBucketName, bucket); System.out.println(); }
public SAMFileSpan removeContentsAfter(final SAMFileSpan fileSpan) { if(fileSpan == null) return clone(); if(!(fileSpan instanceof BAMFileSpan)) throw new SAMException("Unable to compare "); final BAMFileSpan bamFileSpan = (BAMFileSpan)fileSpan; if(bamFileSpan.isEmpty()) return clone(); validateSorted(); final BAMFileSpan trimmedChunkList = new BAMFileSpan(); final long chunkEnd = bamFileSpan.chunks.get(0).getChunkEnd(); for(final Chunk chunkToTrim: chunks) { if(chunkToTrim.getChunkStart() < chunkEnd) { if(chunkToTrim.getChunkEnd() <= chunkEnd) { trimmedChunkList.add(chunkToTrim.clone()); } else { trimmedChunkList.add(new Chunk(chunkToTrim.getChunkStart(),chunkEnd)); } } } return trimmedChunkList; }
public void handleSetDeviceLifecycleStatusByChannelResponse(final DeviceMessageMetadata deviceMessageMetadata, final ResponseMessageResultType result, final OsgpException osgpException, final SetDeviceLifecycleStatusByChannelResponseDto responseDto) { LOGGER.info("handleSetDeviceLifecycleStatusByChannelResponse for MessageType: {}", deviceMessageMetadata.getMessageType()); this.setDeviceLifecycleStatusByChannel(responseDto); final String gatewayDeviceIdentification = deviceMessageMetadata.getDeviceIdentification(); final SetDeviceLifecycleStatusByChannelResponseData responseData = this.managementMapper.map(responseDto, SetDeviceLifecycleStatusByChannelResponseData.class); this.webServiceResponseMessageSender.send( ResponseMessage.newResponseMessageBuilder() .withCorrelationUid(deviceMessageMetadata.getCorrelationUid()) .withOrganisationIdentification(deviceMessageMetadata.getOrganisationIdentification()) .withDeviceIdentification(gatewayDeviceIdentification).withResult(result) .withOsgpException(osgpException).withDataObject(responseData) .withMessagePriority(deviceMessageMetadata.getMessagePriority()).build(), deviceMessageMetadata.getMessageType()); }
protected void onMessageReceived(WorkspaceStatusEvent statusEvent) { final String workspaceId = statusEvent.getWorkspaceId(); switch (statusEvent.getEventType()) { case STARTING: onWorkspaceStarting(workspaceId); break; case RUNNING: onWorkspaceStarted(workspaceId); break; case ERROR: notificationManager.notify(locale.workspaceStartFailed(), FAIL, FLOAT_MODE); loader.setError(LoaderPresenter.Phase.STARTING_WORKSPACE_RUNTIME); final String workspaceName = workspace.getConfig().getName(); final String error = statusEvent.getError(); workspaceServiceClient.getWorkspaces(SKIP_COUNT, MAX_COUNT).then(showErrorDialog(workspaceName, error)); eventBus.fireEvent(new WorkspaceStoppedEvent(workspace)); break; case STOPPING: loader.show(LoaderPresenter.Phase.STOPPING_WORKSPACE); break; case STOPPED: loader.setSuccess(LoaderPresenter.Phase.STOPPING_WORKSPACE); try { eventBus.fireEvent(new WorkspaceStoppedEvent(workspace)); } catch (Exception e) { Log.error(WorkspaceEventsHandler.class, e.getMessage(), e); } startWorkspaceNotification.show(statusEvent.getWorkspaceId()); break; case SNAPSHOT_CREATING: loader.show(LoaderPresenter.Phase.CREATING_WORKSPACE_SNAPSHOT); break; case SNAPSHOT_CREATED: loader.setSuccess(LoaderPresenter.Phase.CREATING_WORKSPACE_SNAPSHOT); snapshotCreator.successfullyCreated(); break; case SNAPSHOT_CREATION_ERROR: loader.setError(LoaderPresenter.Phase.CREATING_WORKSPACE_SNAPSHOT); snapshotCreator.creationError("Snapshot creation error: " + statusEvent.getError()); break; } }